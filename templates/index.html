<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Mini Task Manager</title>
<link rel="stylesheet" href="../static/krasota.css">
</head>
<body>
<h1>‚è∞ Task Manager with Deadlines</h1>
<div class="container">
    <div class="input-group">
        <input id="new-task" placeholder="–ß—Ç–æ –Ω—É–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å?" autocomplete="off">
        <input type="datetime-local" id="due-date">
        <button class="add-btn" onclick="addTask()">–î–æ–±–∞–≤–∏—Ç—å</button>
    </div>
    
    <div class="filters">
        <button class="filter-btn active" onclick="filterTasks('all')">–í—Å–µ</button>
        <button class="filter-btn" onclick="filterTasks('active')">–ê–∫—Ç–∏–≤–Ω—ã–µ</button>
        <button class="filter-btn" onclick="filterTasks('completed')">–í—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ</button>
        <button class="filter-btn" onclick="filterTasks('overdue')">–ü—Ä–æ—Å—Ä–æ—á–µ–Ω–Ω—ã–µ</button>
    </div>
    
    <ul id="task-list"></ul>
    
    <div class="stats">
        <div class="stat-item">
            –í—Å–µ–≥–æ: <span id="total-count">0</span>
        </div>
        <div class="stat-item">
            –í—ã–ø–æ–ª–Ω–µ–Ω–æ: <span id="completed-count">0</span>
        </div>
        <div class="stat-item">
            –ê–∫—Ç–∏–≤–Ω—ã–µ: <span id="active-count">0</span>
        </div>
        <div class="stat-item overdue-stat">
            –ü—Ä–æ—Å—Ä–æ—á–µ–Ω–æ: <span id="overdue-count">0</span>
        </div>
    </div>
</div>

<script>
let currentFilter = 'all';
let tasks = [];

async function fetchTasks() {
    const res = await fetch('/tasks');
    tasks = await res.json();
    renderTasks();
}

function renderTasks() {
    const list = document.getElementById('task-list');
    list.innerHTML = '';
    
    let filteredTasks = tasks;
    
    // –ü—Ä–∏–º–µ–Ω—è–µ–º —Ñ–∏–ª—å—Ç—Ä
    if (currentFilter === 'active') {
        filteredTasks = tasks.filter(t => !t.completed);
    } else if (currentFilter === 'completed') {
        filteredTasks = tasks.filter(t => t.completed);
    } else if (currentFilter === 'overdue') {
        filteredTasks = tasks.filter(t => !t.completed && t.is_overdue);
    }
    
    filteredTasks.forEach((task, index) => {
        const li = document.createElement('li');
        li.style.animationDelay = `${index * 0.05}s`;
        
        if(task.completed) {
            li.classList.add('completed');
        }
        if(task.is_overdue && !task.completed) {
            li.classList.add('overdue');
        }
        
        // –ö–æ–Ω—Ç–µ–Ω—Ç –∑–∞–¥–∞—á–∏
        const contentDiv = document.createElement('div');
        contentDiv.className = 'task-content';
        
        const titleSpan = document.createElement('span');
        titleSpan.className = 'task-title';
        titleSpan.textContent = task.title;
        
        const metaDiv = document.createElement('div');
        metaDiv.className = 'task-meta';
        
        // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Å—Ä–æ–∫–µ
        if (task.due_date) {
            const dueDate = new Date(task.due_date);
            const now = new Date();
            const daysLeft = Math.ceil((dueDate - now) / (1000 * 60 * 60 * 24));
            
            const dueDateSpan = document.createElement('span');
            dueDateSpan.className = 'due-date';
            
            if (task.is_overdue) {
                dueDateSpan.classList.add('urgent');
                dueDateSpan.innerHTML = `‚ö†Ô∏è –ü—Ä–æ—Å—Ä–æ—á–µ–Ω–æ: ${formatDate(dueDate)}`;
            } else if (daysLeft <= 1 && !task.completed) {
                dueDateSpan.classList.add('warning');
                dueDateSpan.innerHTML = `‚è∞ –û—Å—Ç–∞–ª—Å—è 1 –¥–µ–Ω—å: ${formatDate(dueDate)}`;
            } else if (daysLeft <= 3 && !task.completed) {
                dueDateSpan.classList.add('warning');
                dueDateSpan.innerHTML = `‚ö° ${daysLeft} –¥–Ω—è: ${formatDate(dueDate)}`;
            } else {
                dueDateSpan.innerHTML = `üìÖ ${formatDate(dueDate)}`;
            }
            
            metaDiv.appendChild(dueDateSpan);
        }
        
        if (task.is_overdue && !task.completed) {
            const badge = document.createElement('span');
            badge.className = 'overdue-badge';
            badge.textContent = '–ü–†–û–°–†–û–ß–ï–ù–û';
            metaDiv.appendChild(badge);
        }
        
        contentDiv.appendChild(titleSpan);
        contentDiv.appendChild(metaDiv);
        
        // –î–µ–π—Å—Ç–≤–∏—è
        const actionsDiv = document.createElement('div');
        actionsDiv.className = 'task-actions';
        
        const toggleBtn = document.createElement('button');
        toggleBtn.textContent = task.completed ? '‚úì' : '‚óã';
        toggleBtn.style.background = task.completed ? '#4caf50' : '#667eea';
        toggleBtn.onclick = async (e) => {
            e.stopPropagation();
            await toggleTask(task.id);
            fetchTasks();
        };
        
        const delBtn = document.createElement('button');
        delBtn.textContent = '‚úï';
        delBtn.onclick = async (e) => {
            e.stopPropagation();
            if(confirm('–£–¥–∞–ª–∏—Ç—å –∑–∞–¥–∞—á—É?')) {
                await deleteTask(task.id);
                fetchTasks();
            }
        };
        
        actionsDiv.appendChild(toggleBtn);
        actionsDiv.appendChild(delBtn);
        
        li.appendChild(contentDiv);
        li.appendChild(actionsDiv);
        
        // –ö–ª–∏–∫ –ø–æ –∑–∞–¥–∞—á–µ –¥–ª—è –æ—Ç–º–µ—Ç–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
        li.addEventListener('click', async (e) => {
            if (!e.target.closest('button')) {
                await toggleTask(task.id);
                fetchTasks();
            }
        });
        
        list.appendChild(li);
    });
    
    updateStats();
}

function formatDate(date) {
    return date.toLocaleString('ru-RU', {
        day: '2-digit',
        month: '2-digit',
        year: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    });
}

function updateStats() {
    const total = tasks.length;
    const completed = tasks.filter(t => t.completed).length;
    const active = tasks.filter(t => !t.completed).length;
    const overdue = tasks.filter(t => !t.completed && t.is_overdue).length;
    
    document.getElementById('total-count').textContent = total;
    document.getElementById('completed-count').textContent = completed;
    document.getElementById('active-count').textContent = active;
    document.getElementById('overdue-count').textContent = overdue;
}

function filterTasks(filter) {
    currentFilter = filter;
    
    // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—ã–π –∫–ª–∞—Å—Å —É –∫–Ω–æ–ø–æ–∫
    document.querySelectorAll('.filter-btn').forEach(btn => {
        btn.classList.remove('active');
    });
    event.target.classList.add('active');
    
    renderTasks();
}

async function addTask() {
    const input = document.getElementById('new-task');
    const dueDate = document.getElementById('due-date').value;
    
    if(!input.value.trim()) {
        input.style.borderColor = '#ff4757';
        setTimeout(() => input.style.borderColor = '#e0e0e0', 300);
        return;
    }
    
    const taskData = {
        title: input.value,
        due_date: dueDate || null
    };
    
    await fetch('/tasks', { 
        method: 'POST', 
        headers:{'Content-Type':'application/json'}, 
        body: JSON.stringify(taskData) 
    });
    
    input.value = '';
    document.getElementById('due-date').value = '';
    fetchTasks();
}

async function toggleTask(id) {
    await fetch(`/tasks/${id}/toggle`, { method: 'PUT' });
}

async function deleteTask(id) {
    await fetch(`/tasks/${id}`, { method: 'DELETE' });
}

// –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –ø—Ä–æ—Å—Ä–æ—á–µ–∫ –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É
setInterval(fetchTasks, 60000);

fetchTasks();
</script>
</body>
</html>
